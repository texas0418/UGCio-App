import React, { useState, useCallback, useMemo } from "react";
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Alert,
  Platform,
  Modal,
} from "react-native";
import * as Haptics from "expo-haptics";
import {
  Plus,
  X,
  ChevronLeft,
  ChevronRight,
  Calendar as CalendarIcon,
  Briefcase,
  Users,
  Clock,
  Circle,
  Trash2,
  Pencil,
  Zap,
} from "lucide-react-native";
import Colors from "@/constants/colors";
import { useCreator } from "@/contexts/CreatorContext";
import { CalendarEvent, CalendarEventType } from "@/types";

const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const MONTHS = [
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December",
];

const EVENT_TYPES: { value: CalendarEventType; label: string; color: string; icon: any }[] = [
  { value: "project", label: "Project", color: Colors.primary, icon: Briefcase },
  { value: "meeting", label: "Meeting", color: "#8B5CF6", icon: Users },
  { value: "deadline", label: "Deadline", color: Colors.danger, icon: Clock },
  { value: "other", label: "Other", color: Colors.accent, icon: Circle },
];

function getMonthDays(year: number, month: number) {
  const firstDay = new Date(year, month, 1).getDay();
  const daysInMonth = new Date(year, month + 1, 0).getDate();
  const days: (number | null)[] = [];
  for (let i = 0; i < firstDay; i++) days.push(null);
  for (let i = 1; i <= daysInMonth; i++) days.push(i);
  return days;
}

function toDateKey(date: Date | string): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
}

export default function CalendarScreen() {
  const { calendarEvents, addCalendarEvent, updateCalendarEvent, removeCalendarEvent } = useCreator();
  const [currentDate, setCurrentDate] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState<string>(toDateKey(new Date()));
  const [showAddForm, setShowAddForm] = useState(false);
  const [editingEvent, setEditingEvent] = useState<CalendarEvent | null>(null);
  const [formData, setFormData] = useState({
    title: "",
    time: "",
    type: "project" as CalendarEventType,
    brandName: "",
    notes: "",
  });

  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  const days = useMemo(() => getMonthDays(year, month), [year, month]);

  const eventsByDate = useMemo(() => {
    const map: Record<string, CalendarEvent[]> = {};
    calendarEvents.forEach((e) => {
      const key = toDateKey(e.date);
      if (!map[key]) map[key] = [];
      map[key].push(e);
    });
    return map;
  }, [calendarEvents]);

  const selectedEvents = useMemo(() => {
    return (eventsByDate[selectedDate] || []).sort((a, b) => {
      if (a.time && b.time) return a.time.localeCompare(b.time);
      if (a.time) return -1;
      if (b.time) return 1;
      return 0;
    });
  }, [eventsByDate, selectedDate]);

  const today = toDateKey(new Date());

  const goToPrevMonth = () => {
    setCurrentDate(new Date(year, month - 1, 1));
  };
  const goToNextMonth = () => {
    setCurrentDate(new Date(year, month + 1, 1));
  };
  const goToToday = () => {
    const now = new Date();
    setCurrentDate(now);
    setSelectedDate(toDateKey(now));
  };

  const handleDayPress = (day: number) => {
    const key = `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
    setSelectedDate(key);
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  };

  const resetForm = () => {
    setFormData({ title: "", time: "", type: "project", brandName: "", notes: "" });
  };

  const handleAdd = useCallback(() => {
    if (!formData.title.trim()) {
      Alert.alert("Missing Title", "Please enter an event title.");
      return;
    }
    const event: CalendarEvent = {
      id: `cal_${Date.now()}`,
      title: formData.title.trim(),
      date: new Date(selectedDate + "T12:00:00").toISOString(),
      time: formData.time.trim() || undefined,
      type: formData.type,
      brandName: formData.brandName.trim() || undefined,
      notes: formData.notes.trim() || undefined,
      autoGenerated: false,
      createdAt: new Date().toISOString(),
    };
    addCalendarEvent(event);
    resetForm();
    setShowAddForm(false);
    if (Platform.OS !== "web") {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
  }, [formData, selectedDate, addCalendarEvent]);

  const handleSaveEdit = useCallback(() => {
    if (!editingEvent) return;
    updateCalendarEvent(editingEvent.id, {
      title: formData.title.trim(),
      time: formData.time.trim() || undefined,
      type: formData.type,
      brandName: formData.brandName.trim() || undefined,
      notes: formData.notes.trim() || undefined,
    });
    setEditingEvent(null);
    resetForm();
    if (Platform.OS !== "web") {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
  }, [editingEvent, formData, updateCalendarEvent]);

  const openEventOptions = useCallback(
    (event: CalendarEvent) => {
      if (Platform.OS !== "web") {
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      }
      Alert.alert(event.title, event.autoGenerated ? "Auto-generated from deal" : "What would you like to do?", [
        {
          text: "Edit",
          onPress: () => {
            setFormData({
              title: event.title,
              time: event.time || "",
              type: event.type,
              brandName: event.brandName || "",
              notes: event.notes || "",
            });
            setEditingEvent(event);
          },
        },
        {
          text: "Delete",
          style: "destructive",
          onPress: () => {
            removeCalendarEvent(event.id);
            if (Platform.OS !== "web") {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
            }
          },
        },
        { text: "Cancel", style: "cancel" },
      ]);
    },
    [removeCalendarEvent]
  );

  const getEventTypeConfig = (type: CalendarEventType) => {
    return EVENT_TYPES.find((t) => t.value === type) || EVENT_TYPES[3];
  };

  const getDotsForDay = (day: number) => {
    const key = `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
    const events = eventsByDate[key];
    if (!events || events.length === 0) return [];
    const types = [...new Set(events.map((e) => e.type))];
    return types.slice(0, 3).map((t) => getEventTypeConfig(t).color);
  };

  const selectedDateFormatted = useMemo(() => {
    const [y, m, d] = selectedDate.split("-").map(Number);
    const date = new Date(y, m - 1, d);
    return date.toLocaleDateString("en-US", { weekday: "long", month: "long", day: "numeric" });
  }, [selectedDate]);

  const upcomingCount = useMemo(() => {
    const todayDate = new Date();
    todayDate.setHours(0, 0, 0, 0);
    return calendarEvents.filter((e) => new Date(e.date) >= todayDate).length;
  }, [calendarEvents]);

  const renderForm = (isEdit: boolean) => (
    <View style={styles.formCard}>
      <View style={styles.formHeader}>
        <Text style={styles.formTitle}>{isEdit ? "Edit Event" : "New Event"}</Text>
        <TouchableOpacity
          onPress={() => {
            if (isEdit) setEditingEvent(null);
            else setShowAddForm(false);
            resetForm();
          }}
          style={styles.closeBtn}
        >
          <X size={18} color={Colors.textSecondary} />
        </TouchableOpacity>
      </View>

      <Text style={styles.fieldLabel}>Title</Text>
      <TextInput
        style={styles.input}
        value={formData.title}
        onChangeText={(t) => setFormData((p) => ({ ...p, title: t }))}
        placeholder="e.g. Brand shoot, Strategy call..."
        placeholderTextColor={Colors.textTertiary}
      />

      <Text style={styles.fieldLabel}>Type</Text>
      <View style={styles.typeRow}>
        {EVENT_TYPES.map((t) => {
          const isActive = formData.type === t.value;
          const Icon = t.icon;
          return (
            <TouchableOpacity
              key={t.value}
              style={[styles.typeChip, isActive && { backgroundColor: t.color + "20", borderColor: t.color }]}
              onPress={() => setFormData((p) => ({ ...p, type: t.value }))}
            >
              <Icon size={12} color={isActive ? t.color : Colors.textTertiary} />
              <Text style={[styles.typeChipText, isActive && { color: t.color }]}>{t.label}</Text>
            </TouchableOpacity>
          );
        })}
      </View>

      <Text style={styles.fieldLabel}>Time (optional)</Text>
      <TextInput
        style={styles.input}
        value={formData.time}
        onChangeText={(t) => setFormData((p) => ({ ...p, time: t }))}
        placeholder="e.g. 2:00 PM"
        placeholderTextColor={Colors.textTertiary}
      />

      <Text style={styles.fieldLabel}>Brand (optional)</Text>
      <TextInput
        style={styles.input}
        value={formData.brandName}
        onChangeText={(t) => setFormData((p) => ({ ...p, brandName: t }))}
        placeholder="e.g. Nike, Glossier..."
        placeholderTextColor={Colors.textTertiary}
      />

      <Text style={styles.fieldLabel}>Notes (optional)</Text>
      <TextInput
        style={[styles.input, styles.notesInput]}
        value={formData.notes}
        onChangeText={(t) => setFormData((p) => ({ ...p, notes: t }))}
        placeholder="Any details..."
        placeholderTextColor={Colors.textTertiary}
        multiline
      />

      <TouchableOpacity
        style={styles.saveButton}
        onPress={isEdit ? handleSaveEdit : handleAdd}
        activeOpacity={0.8}
      >
        <Text style={styles.saveButtonText}>{isEdit ? "Save Changes" : "Add Event"}</Text>
      </TouchableOpacity>
    </View>
  );

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
        {/* Month nav */}
        <View style={styles.monthNav}>
          <TouchableOpacity onPress={goToPrevMonth} style={styles.navBtn}>
            <ChevronLeft size={20} color={Colors.text} />
          </TouchableOpacity>
          <TouchableOpacity onPress={goToToday}>
            <Text style={styles.monthTitle}>{MONTHS[month]} {year}</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={goToNextMonth} style={styles.navBtn}>
            <ChevronRight size={20} color={Colors.text} />
          </TouchableOpacity>
        </View>

        {/* Day headers */}
        <View style={styles.dayHeaders}>
          {DAYS.map((d) => (
            <Text key={d} style={styles.dayHeader}>{d}</Text>
          ))}
        </View>

        {/* Calendar grid */}
        <View style={styles.calendarGrid}>
          {days.map((day, idx) => {
            if (day === null) {
              return <View key={`empty-${idx}`} style={styles.dayCell} />;
            }
            const key = `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
            const isToday = key === today;
            const isSelected = key === selectedDate;
            const dots = getDotsForDay(day);

            return (
              <TouchableOpacity
                key={key}
                style={[
                  styles.dayCell,
                  isSelected && styles.dayCellSelected,
                  isToday && !isSelected && styles.dayCellToday,
                ]}
                onPress={() => handleDayPress(day)}
                activeOpacity={0.7}
              >
                <Text
                  style={[
                    styles.dayText,
                    isSelected && styles.dayTextSelected,
                    isToday && !isSelected && styles.dayTextToday,
                  ]}
                >
                  {day}
                </Text>
                {dots.length > 0 && (
                  <View style={styles.dotsRow}>
                    {dots.map((color, i) => (
                      <View key={i} style={[styles.dot, { backgroundColor: color }]} />
                    ))}
                  </View>
                )}
              </TouchableOpacity>
            );
          })}
        </View>

        {/* Stats bar */}
        <View style={styles.statsBar}>
          <View style={styles.statItem}>
            <CalendarIcon size={14} color={Colors.primary} />
            <Text style={styles.statText}>{selectedEvents.length} on this day</Text>
          </View>
          <View style={styles.statItem}>
            <Zap size={14} color={Colors.success} />
            <Text style={styles.statText}>{upcomingCount} upcoming</Text>
          </View>
        </View>

        {/* Selected day header */}
        <View style={styles.dayEventsHeader}>
          <Text style={styles.dayEventsTitle}>{selectedDateFormatted}</Text>
          <TouchableOpacity
            style={styles.addEventBtn}
            onPress={() => {
              resetForm();
              setShowAddForm(true);
            }}
          >
            <Plus size={16} color={Colors.primary} />
            <Text style={styles.addEventText}>Add</Text>
          </TouchableOpacity>
        </View>

        {/* Add form */}
        {showAddForm && renderForm(false)}

        {/* Event list */}
        {selectedEvents.length > 0 ? (
          <View style={styles.eventsList}>
            {selectedEvents.map((event) => {
              const config = getEventTypeConfig(event.type);
              const Icon = config.icon;
              return (
                <TouchableOpacity
                  key={event.id}
                  style={styles.eventCard}
                  onPress={() => openEventOptions(event)}
                  activeOpacity={0.8}
                >
                  <View style={[styles.eventColorBar, { backgroundColor: config.color }]} />
                  <View style={styles.eventContent}>
                    <View style={styles.eventTop}>
                      <View style={styles.eventTitleRow}>
                        <Icon size={14} color={config.color} />
                        <Text style={styles.eventTitle} numberOfLines={1}>{event.title}</Text>
                      </View>
                      {event.autoGenerated && (
                        <View style={styles.autoBadge}>
                          <Zap size={9} color={Colors.accent} />
                          <Text style={styles.autoBadgeText}>Auto</Text>
                        </View>
                      )}
                    </View>
                    <View style={styles.eventMeta}>
                      {event.time && <Text style={styles.eventTime}>{event.time}</Text>}
                      {event.brandName && (
                        <View style={styles.brandChip}>
                          <Text style={styles.brandChipText}>{event.brandName}</Text>
                        </View>
                      )}
                    </View>
                    {event.notes && (
                      <Text style={styles.eventNotes} numberOfLines={2}>{event.notes}</Text>
                    )}
                  </View>
                </TouchableOpacity>
              );
            })}
          </View>
        ) : (
          !showAddForm && (
            <View style={styles.emptyDay}>
              <Text style={styles.emptyDayText}>No events on this day</Text>
              <TouchableOpacity
                style={styles.emptyAddBtn}
                onPress={() => {
                  resetForm();
                  setShowAddForm(true);
                }}
              >
                <Plus size={14} color={Colors.primary} />
                <Text style={styles.emptyAddText}>Add Event</Text>
              </TouchableOpacity>
            </View>
          )
        )}

        <View style={{ height: 40 }} />
      </ScrollView>

      {/* Edit modal */}
      <Modal
        visible={!!editingEvent}
        animationType="slide"
        presentationStyle="pageSheet"
        onRequestClose={() => { setEditingEvent(null); resetForm(); }}
      >
        <View style={styles.modalContainer}>
          <ScrollView contentContainerStyle={styles.modalContent} showsVerticalScrollIndicator={false}>
            {renderForm(true)}
          </ScrollView>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.background,
  },
  content: {
    padding: 16,
  },
  monthNav: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 16,
  },
  navBtn: {
    width: 36,
    height: 36,
    borderRadius: 12,
    backgroundColor: Colors.surface,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
    borderColor: Colors.border,
  },
  monthTitle: {
    fontSize: 18,
    fontWeight: "700" as const,
    color: Colors.text,
  },
  dayHeaders: {
    flexDirection: "row",
    marginBottom: 8,
  },
  dayHeader: {
    flex: 1,
    textAlign: "center",
    fontSize: 12,
    fontWeight: "600" as const,
    color: Colors.textTertiary,
    textTransform: "uppercase" as const,
  },
  calendarGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    marginBottom: 16,
  },
  dayCell: {
    width: `${100 / 7}%` as unknown as number,
    aspectRatio: 1,
    alignItems: "center",
    justifyContent: "center",
    borderRadius: 12,
  },
  dayCellSelected: {
    backgroundColor: Colors.primary,
  },
  dayCellToday: {
    backgroundColor: Colors.surface,
    borderWidth: 1,
    borderColor: Colors.primary,
  },
  dayText: {
    fontSize: 14,
    fontWeight: "500" as const,
    color: Colors.text,
  },
  dayTextSelected: {
    color: Colors.white,
    fontWeight: "700" as const,
  },
  dayTextToday: {
    color: Colors.primary,
    fontWeight: "700" as const,
  },
  dotsRow: {
    flexDirection: "row",
    gap: 2,
    marginTop: 2,
    position: "absolute",
    bottom: 6,
  },
  dot: {
    width: 4,
    height: 4,
    borderRadius: 2,
  },
  statsBar: {
    flexDirection: "row",
    gap: 16,
    marginBottom: 20,
    paddingHorizontal: 4,
  },
  statItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  statText: {
    fontSize: 13,
    color: Colors.textSecondary,
    fontWeight: "500" as const,
  },
  dayEventsHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 12,
  },
  dayEventsTitle: {
    fontSize: 16,
    fontWeight: "700" as const,
    color: Colors.text,
    flex: 1,
  },
  addEventBtn: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 8,
    backgroundColor: Colors.primaryLight,
  },
  addEventText: {
    fontSize: 13,
    fontWeight: "600" as const,
    color: Colors.primary,
  },
  eventsList: {
    gap: 8,
  },
  eventCard: {
    flexDirection: "row",
    backgroundColor: Colors.surface,
    borderRadius: 14,
    overflow: "hidden",
    borderWidth: 1,
    borderColor: Colors.border,
  },
  eventColorBar: {
    width: 4,
  },
  eventContent: {
    flex: 1,
    padding: 14,
    gap: 6,
  },
  eventTop: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  eventTitleRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    flex: 1,
  },
  eventTitle: {
    fontSize: 15,
    fontWeight: "600" as const,
    color: Colors.text,
    flex: 1,
  },
  autoBadge: {
    flexDirection: "row",
    alignItems: "center",
    gap: 3,
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 6,
    backgroundColor: Colors.accentLight,
  },
  autoBadgeText: {
    fontSize: 10,
    fontWeight: "600" as const,
    color: Colors.accent,
  },
  eventMeta: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  eventTime: {
    fontSize: 13,
    color: Colors.textSecondary,
    fontWeight: "500" as const,
  },
  brandChip: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 6,
    backgroundColor: Colors.surfaceElevated,
  },
  brandChipText: {
    fontSize: 11,
    color: Colors.textSecondary,
    fontWeight: "500" as const,
  },
  eventNotes: {
    fontSize: 13,
    color: Colors.textTertiary,
    lineHeight: 18,
  },
  emptyDay: {
    alignItems: "center",
    paddingVertical: 30,
    gap: 12,
  },
  emptyDayText: {
    fontSize: 14,
    color: Colors.textTertiary,
  },
  emptyAddBtn: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 10,
    borderWidth: 1.5,
    borderColor: Colors.border,
    borderStyle: "dashed",
  },
  emptyAddText: {
    fontSize: 14,
    fontWeight: "600" as const,
    color: Colors.primary,
  },
  formCard: {
    backgroundColor: Colors.surface,
    borderRadius: 16,
    padding: 18,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: Colors.border,
  },
  formHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 16,
  },
  formTitle: {
    fontSize: 18,
    fontWeight: "700" as const,
    color: Colors.text,
  },
  closeBtn: {
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: Colors.surfaceElevated,
    alignItems: "center",
    justifyContent: "center",
  },
  fieldLabel: {
    fontSize: 12,
    fontWeight: "600" as const,
    color: Colors.textSecondary,
    marginBottom: 6,
    textTransform: "uppercase" as const,
    letterSpacing: 0.5,
  },
  input: {
    backgroundColor: Colors.surfaceElevated,
    borderRadius: 12,
    padding: 14,
    fontSize: 15,
    color: Colors.text,
    borderWidth: 1,
    borderColor: Colors.border,
    marginBottom: 14,
  },
  notesInput: {
    minHeight: 60,
    textAlignVertical: "top",
  },
  typeRow: {
    flexDirection: "row",
    gap: 6,
    marginBottom: 14,
  },
  typeChip: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 4,
    paddingVertical: 8,
    borderRadius: 10,
    backgroundColor: Colors.surfaceElevated,
    borderWidth: 1,
    borderColor: Colors.border,
  },
  typeChipText: {
    fontSize: 11,
    fontWeight: "600" as const,
    color: Colors.textTertiary,
  },
  saveButton: {
    backgroundColor: Colors.primary,
    borderRadius: 12,
    padding: 16,
    alignItems: "center",
  },
  saveButtonText: {
    color: Colors.white,
    fontSize: 16,
    fontWeight: "700" as const,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: Colors.background,
  },
  modalContent: {
    padding: 20,
    paddingTop: 20,
  },
});
